# Decorator

## Introdu√ß√£o

O padr√£o de projeto *Decorator* √© um dos padr√µes estruturais definidos pela *Gang of Four* (GoF) no livro cl√°ssico *Design Patterns: Elements of Reusable Object-Oriented Software* (Gamma et al., 1994). Ele √© utilizado para adicionar comportamentos ou responsabilidades a objetos individuais dinamicamente, sem modificar sua estrutura original.

## Defini√ß√£o e Prop√≥sito

O *Decorator* tem como objetivo permitir que responsabilidades adicionais sejam atribu√≠das a um objeto de forma din√¢mica, oferecendo uma alternativa flex√≠vel √† heran√ßa para a extens√£o de funcionalidades. Isso √© √∫til em situa√ß√µes em que v√°rias combina√ß√µes de comportamentos diferentes precisam ser aplicadas a objetos sem criar subclasses excessivas.

O padr√£o *Decorator* √© similar ao conceito de "envolt√≥rios" ou "camadas" ao redor de um objeto, onde cada camada adiciona funcionalidades ou modifica o comportamento existente. Ao contr√°rio de abordagens baseadas em heran√ßa, os decoradores trabalham com composi√ß√£o, tornando o c√≥digo mais flex√≠vel e modular.

Linguagens de programa√ß√£o como Python e Java oferecem suporte direto ou indireto para o padr√£o *Decorator*. No Python, decoradores s√£o uma funcionalidade nativa utilizada para modificar ou estender o comportamento de fun√ß√µes e m√©todos.

<br>
<center>
<figcaption> 

**Figura 1** - Explica√ß√£o do *Decorator*.

![Explica√ß√£o do Decorator](../Images/decorator/decorator-explain.png)

**Fonte:** <a href="https://refactoring.guru/design-patterns/decorator" target="_blank">Refactoring Guru</a>, 2025.

</figcaption>
</center>

## Estrutura

A organiza√ß√£o do padr√£o *Decorator* √© composta pelos seguintes elementos:

1. **Componente**: Define a interface compartilhada por todos os objetos, incluindo os que ser√£o decorados e os pr√≥prios decoradores.

2. **Componente Concreto**: Representa a classe que implementa o comportamento padr√£o dos objetos a serem decorados. Esse comportamento pode ser estendido dinamicamente por meio dos decoradores.

3. **Decorador Base**: Uma classe que encapsula outro objeto, referenciando-o atrav√©s de um campo que segue a interface do componente. Isso permite que tanto objetos concretos quanto decoradores sejam armazenados e manipulados de maneira uniforme. O decorador base redireciona as opera√ß√µes para o objeto encapsulado.

4. **Decoradores Concretos**: S√£o extens√µes espec√≠ficas do decorador base, que adicionam ou modificam funcionalidades. Eles implementam l√≥gica adicional antes ou depois de delegar as chamadas ao objeto encapsulado.

5. **Cliente**: √â respons√°vel por combinar objetos e decoradores em diferentes configura√ß√µes, mantendo sempre a intera√ß√£o por meio da interface do componente. Isso possibilita empilhar m√∫ltiplas camadas de decoradores, criando comportamentos complexos de maneira flex√≠vel.

## Utilidade do Decorator

- Quando √© necess√°rio adicionar funcionalidades a objetos de forma din√¢mica, sem alterar sua estrutura original;
- Ideal para situa√ß√µes em que diferentes combina√ß√µes de comportamentos precisam ser aplicadas a objetos, evitando a cria√ß√£o de m√∫ltiplas subclasses;
- Permite adicionar ou modificar funcionalidades em tempo de execu√ß√£o, adaptando o comportamento dos objetos conforme a necessidade.

## Vantagens do Decorator

- **Flexibilidade**: Permite estender funcionalidades sem alterar a classe original ou afetar outros objetos;
- **Composi√ß√£o**: Estimula a composi√ß√£o sobre a heran√ßa, tornando o c√≥digo mais modular e reutiliz√°vel;
- **Camadas de Funcionalidade**: Facilita a aplica√ß√£o de m√∫ltiplas responsabilidades ou comportamentos ao mesmo objeto, combinando decoradores de maneira flex√≠vel.

## Desvantagens do Decorator

- **Complexidade Adicional**: A introdu√ß√£o de decoradores pode tornar o c√≥digo mais dif√≠cil de compreender e manter, devido ao aumento no n√∫mero de classes;
- **Depura√ß√£o Dif√≠cil**: A cadeia de chamadas entre decoradores e o objeto original pode dificultar a identifica√ß√£o de problemas;
- **Sobrecarga de Configura√ß√£o**: Aplicar muitos decoradores a um √∫nico objeto pode resultar em sobrecarga de configura√ß√£o e aumento na complexidade de gerenciamento.

## Aplica√ß√£o do Decorator

A aplica√ß√£o do padr√£o de projeto levou em conta o cen√°rio de uso do controle de acesso no brech√≥.

### Elabora√ß√£o do Diagrama

O desenvolvimento do diagrama do padr√£o de projeto _Decorator_ deve envolver as cinco estruturas apresentadas no t√≥pico [Estrutura](#estrutura). O diagrama apresentado na **Figura 1** abaixo se refere √† aplica√ß√£o do padr√£o _Decorator_ em um caso de uso fict√≠cio, relacionado ao tema do trabalho do Grupo 02: UnBrech√≥.

<center>
<figcaption>

**Figura 1** - Diagrama do padr√£o de projeto _Decorator_.

</figcaption>

![Diagrama do padr√£o de projeto Decorator](../Images/decorator/diagramaDecorator-2.png)

<figcaption>

**Fonte:** <a href="https://github.com/guinuto" target="_blank">Guilherme Evangelista</a> e <a href="https://github.com/luizpettengill" target="_blank">Luiz Guilherme</a>, 2025.

</figcaption>
</center>

A utiliza√ß√£o de um caso de uso fict√≠cio foi incentivada pela proposta acad√™mica do presente projeto, de modo que fosse poss√≠vel estudar os diversos padr√µes existentes antes de escolher um padr√£o definitivo a ser utilizado no projeto do UnBrech√≥.

As estruturas, conforme definido no t√≥pico [Estrutura](#estrutura), s√£o aplicadas no diagrama da seguinte forma:

1. _Component_: Product.

2. _Concrete Component_: BasicProduct.

3. _Decorator Abstrato_: ProductDecorator.

4. _Concrete Decorator_: PremiumPackaging e ExtendedWarranty

### Desenvolvimento do C√≥digo

O desenvolvimento do c√≥digo para aplica√ß√£o pr√°tica do padr√£o de projeto *Decorator* foi feito utilizando a linguagem de programa√ß√£o Python e, para execut√°-lo, deve-se seguir os passos a seguir:

1. Entrar na pasta code/decorator/

2. Ter instalado o node/npm

3. Executar o projeto com o comando npm start

O resultado da execu√ß√£o dos comandos deve ser um output no console com produtos de acordo com a garantia e forma de entrega.

<center>
<figcaption>

**Figura 2** - Resultado da execu√ß√£o do script.

![Resultado decorator](../Images/decorator/decorator-resultado.png)

**Fonte:** <a href="https://github.com/eduard0803" target="_blank">Eduardo Belarmino</a> e <a href="https://github.com/guinuto" target="_blank">Guilherme Evangelista</a>, 2025.

</center>


- Decorator abstrato.

```js
const Product = require('./Product');
class ProductDecorator extends Product {
    constructor(product) {
        super();
        this.product = product;
    }

    getDescription() {
        return this.product.getDescription();
    }

    getPrice() {
        return this.product.getPrice();
    }
}

module.exports = ProductDecorator;
```

- Decorator concreto.

```js
const ProductDecorator = require('./ProductDecorator');

class PremiumPackaging extends ProductDecorator {
    getDescription() {
        return this.product.getDescription() + " + Embalagem Premium";
    }

    getPrice() {
        return this.product.getPrice() + 10.0;
    }
}

module.exports = PremiumPackaging;
```

- Classe para representar o concrete component

```js
const Product = require('./Product');
class BasicProduct extends Product {
    getDescription() {
        return "Produto Base";
    }

    getPrice() {
        return 50.0;
    }
}

module.exports = BasicProduct;
```

- Main.

```js
const BasicProduct = require('./BasicProduct');
const ExtendedWarranty = require('./ExtendedWarranty');
const PremiumPackaging = require('./PremiumPackaging');

// üöÄ Teste do Padr√£o Decorator
function main() {
    // Produto Base
    let product = new BasicProduct();
    console.log(`${product.getDescription()} - R$${product.getPrice()}`);

    // Adiciona Garantia Estendida
    product = new ExtendedWarranty(product);
    console.log(`${product.getDescription()} - R$${product.getPrice()}`);

    // Adiciona Embalagem Premium
    product = new PremiumPackaging(product);
    console.log(`${product.getDescription()} - R$${product.getPrice()}`);
}

// üéØ Executa o teste
main();
```


## Refer√™ncias

> Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.

> Decorator. Refactoring Guru, 2025. Dispon√≠vel em: <https://refactoring.guru/design-patterns/decorator>. Acesso em: 03 jan. de 2025.

## Hist√≥rico de Vers√£o

| Vers√£o | Data       | Descri√ß√£o            | Autor(es)                                        | Revisor(es) | Resultado da Revis√£o |
| ------ | ---------- | -------------------- | ------------------------------------------------ | ----------- | -------------------- |
| `1.0`  | 03/01/2025 | Cria√ß√£o do documento | [Eduardo Belarmino](https://github.com/eduard0803) | [Lucas Spinosa](https://github.com/LucasSpinosa) | Aprovado para merge |
| `1.1`  | 03/01/2025 | Adi√ß√£o do c√≥digo de exemplo | [Eduardo Belarmino](https://github.com/eduard0803) | [Lucas Spinosa](https://github.com/LucasSpinosa) | Aprovado para merge |
| `1.2`  | 05/01/2025 | Ajuste de c√≥digo do exemplo | [Guilherme Evangelista](https://github.com/guinuto) , [Luiz Guilherme](https://github.com/luizpettengill) | [Ana Hoffmann](https://github.com/AnHoff) | --- |
| `1.3`  | 06/01/2025 | Adi√ß√£o do diagrama | [Guilherme Evangelista](https://github.com/guinuto) , [Luiz Guilherme](https://github.com/luizpettengill) | [Ana Hoffmann](https://github.com/AnHoff) | Aprova√ß√£o de PR, padroniza√ß√£o do documento |
